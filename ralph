#!/usr/bin/env bash

# ralph - RalphLoop Autonomous Development Agent
# Usage: ./ralph <iterations>
#
# Prompt can be provided via:
# 1. prompt.md file (default)
# 2. RALPH_PROMPT environment variable (direct prompt text)
# 3. RALPH_PROMPT_FILE environment variable (path to prompt file)
#
# Custom commands can trigger evaluation loops via:
# - RALPH_COMMAND: Execute a specific command mode
# - RALPH_BACKEND: Use a specific backend configuration
# - RALPH_MODE: Set evaluation mode (autonomous, interactive, validation)
#
# Supported custom commands:
#   ralf-trigger --iterations N --mode MODE --backend BACKEND
#   ralf-status [--progress] [--state] [--backends]
#   ralf-config [--get key] [--set key=value] [--list]
#
# Environment variables:
#   RALPH_TIMEOUT       - Timeout for opencode commands in seconds (default: 1800 = 30 minutes)
#   RALPH_MEMORY_LIMIT  - Memory limit in KB (default: 2097152 = 2GB)
#   RALPH_LOG_LEVEL     - OpenCode log level: DEBUG, INFO, WARN, ERROR (default: WARN)
#   RALPH_PRINT_LOGS    - Print opencode logs to stderr: true/false (default: false)
#   RALPH_PROMPT        - Direct prompt text
#   RALPH_PROMPT_FILE   - Path to prompt file
#   RALPH_COMMAND       - Custom command to execute
#   RALPH_BACKEND       - Backend to use
#   RALPH_MODE          - Mode: autonomous, interactive, validation
#   RALPH_SOURCED_FOR_TEST - Internal: set to 1 when sourcing for testing

set -e -u -o pipefail

# Configuration
MAX_ROUNDS=${1:-${MAX_ROUNDS:-100}}
PROGRESS_FILE="progress.md"
PROMPT_FILE="prompt.md"
VALIDATION_ISSUES_FILE=".ralph_validation_issues.txt"
BACKENDS_DIR="backends"

# Timeout and memory configuration (customizable via environment)
RALPH_TIMEOUT=${RALPH_TIMEOUT:-1800}        # Default: 30 minutes in seconds
RALPH_MEMORY_LIMIT=${RALPH_MEMORY_LIMIT:-4194304}  # Default: 4GB in KB

# OpenCode logging configuration
RALPH_LOG_LEVEL=${RALPH_LOG_LEVEL:-WARN}   # Default: WARN to avoid too much output
RALPH_PRINT_LOGS=${RALPH_PRINT_LOGS:-false}  # Default: false (logs to file instead)

# Note: Progress file management is delegated entirely to the AI agent.
# The agent is responsible for updating and maintaining progress.md.

# Build opencode command with logging options
OPENCODE_OPTS=""
if [ -n "$RALPH_LOG_LEVEL" ]; then
  OPENCODE_OPTS="$OPENCODE_OPTS --log-level $RALPH_LOG_LEVEL"
fi
if [ "$RALPH_PRINT_LOGS" = "true" ]; then
  OPENCODE_OPTS="$OPENCODE_OPTS --print-logs"
fi

# Custom command configuration
RALPH_COMMAND="${RALPH_COMMAND:-}"
RALPH_BACKEND="${RALPH_BACKEND:-}"
RALPH_MODE="${RALPH_MODE:-autonomous}"

# Memory management to prevent OOM kills (exit code 137)
# Note: ulimit commands cause opencode to crash in containers, so they are disabled.
# Container memory limits are handled by Docker/Podman, not by ulimit.
# The RALPH_MEMORY_LIMIT env var is kept for backwards compatibility but is not used.

# Cleanup temp files and session marker on exit
ralph_cleanup() {
  rm -f /tmp/ralph_output_*.txt /tmp/ralph_validation_*.txt 2>/dev/null
  local cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/ralph"
  rm -f "${cache_dir}/.session_prompt_$$" "${cache_dir}/.ai_skip_editor_$$" 2>/dev/null
}
trap 'ralph_cleanup' EXIT

# Handle custom command mode
handle_custom_command() {
  if [[ -n "$RALPH_COMMAND" ]]; then
    echo "========================================"
    echo "üîß Custom Command Mode: $RALPH_COMMAND"
    echo "========================================"
    echo "  Backend: ${RALPH_BACKEND:-default}"
    echo "  Mode: $RALPH_MODE"
    echo "========================================"

    # Export backend and mode for the agent
    export RALPH_BACKEND="$RALPH_BACKEND"
    export RALPH_MODE="$RALPH_MODE"
  fi
}

# Load backend configuration if available
load_backend_config() {
  if [[ -n "$RALPH_BACKEND" ]]; then
    local backend_config="${BACKENDS_DIR}/${RALPH_BACKEND}/config.json"
    if [[ -f "$backend_config" ]]; then
      echo "üì¶ Loading backend configuration: $RALPH_BACKEND"

      # Load backend-specific settings if jq is available
      if command -v jq &> /dev/null; then
        local backend_enabled
        backend_enabled=$(jq -r '.enabled // false' "$backend_config" 2>/dev/null || echo "false")

        if [[ "$backend_enabled" == "true" ]]; then
          echo "‚úÖ Backend '$RALPH_BACKEND' enabled and configured"
        else
          echo "‚ö†Ô∏è Backend '$RALPH_BACKEND' is disabled in configuration"
        fi
      fi
    else
      echo "‚ö†Ô∏è Backend configuration not found: $backend_config"
    fi
  fi
}

# Initialize custom command support
handle_custom_command
load_backend_config

# Display configuration info
display_config() {
  echo "========================================"
  echo "‚öôÔ∏è  RalphLoop Configuration"
  echo "========================================"
  echo "  Timeout:        ${RALPH_TIMEOUT}s ($((RALPH_TIMEOUT / 60)) minutes)"
  echo "  Memory Limit:   ${RALPH_MEMORY_LIMIT}KB ($((RALPH_MEMORY_LIMIT / 1024 / 1024))GB)"
  echo "  Log Level:      $RALPH_LOG_LEVEL"
  echo "  Print Logs:     $RALPH_PRINT_LOGS"
  echo "  Max Iterations: $MAX_ROUNDS"
  if [ -n "$RALPH_BACKEND" ]; then
    echo "  Backend:        $RALPH_BACKEND"
    echo "  Mode:           $RALPH_MODE"
  fi
  echo "========================================"
}
# Display configuration info (only when not sourcing for tests)
if [ "${RALPH_SOURCED_FOR_TEST:-0}" != "1" ]; then
  display_config
fi

# Validate MAX_ROUNDS is a positive integer
validate_max_rounds() {
  if ! [[ "$MAX_ROUNDS" =~ ^[0-9]+$ ]]; then
    echo "Error: MAX_ROUNDS must be a positive integer, got: '$MAX_ROUNDS'" >&2
    exit 1
  fi
  if [ "$MAX_ROUNDS" -eq 0 ]; then
    echo "Error: MAX_ROUNDS must be greater than 0" >&2
    exit 1
  fi
}

# Skip initialization when sourcing for testing
if [ "${RALPH_SOURCED_FOR_TEST:-0}" != "1" ]; then
  validate_max_rounds
fi

# =============================================================================
# Template Functions
# =============================================================================

# Get the standard prompt template
get_standard_template() {
  cat <<'TEMPLATE'
# Project Goal

[Describe what you want to accomplish]

## Acceptance Criteria

- [ ] Criterion 1
- [ ] Criterion 2

## Context

[Any additional context, constraints, or preferences]
TEMPLATE
}

# Get the quickfix template for small changes
get_quickfix_template() {
  cat <<'TEMPLATE'
# QuickFix

## Issue
[Describe the bug or small change needed]

## Expected Behavior
[What should happen after the fix]

## Files Affected
- [ ] File 1

## Acceptance Criteria
- [ ] The fix is implemented
- [ ] No regressions introduced
TEMPLATE
}

# Get blank template
get_blank_template() {
  cat <<'TEMPLATE'
# Project

TEMPLATE
}

# Get the AI idea template (with optional prefilled content)
get_ai_idea_template() {
  local prefill="${1:-}"
  if [ -n "$prefill" ]; then
    echo "$prefill"
  else
    cat <<'TEMPLATE'
# Describe Your Project Idea

Write a brief description of what you want to build or accomplish.
The AI will expand this into a full project specification.

## Your Idea

[Replace this with your project idea - be as detailed or brief as you like]

## Optional: Additional Context

[Any constraints, preferences, or technical requirements]
TEMPLATE
  fi
}

# =============================================================================
# Template Selection Menu
# =============================================================================

# Show template selection menu and return the selected type
show_template_menu() {
  # Check for environment variable override
  if [ -n "${RALPH_TEMPLATE_TYPE:-}" ]; then
    case "${RALPH_TEMPLATE_TYPE}" in
      standard|quickfix|ai|example|blank)
        echo "${RALPH_TEMPLATE_TYPE}"
        return 0
        ;;
      *)
        echo "Warning: Invalid RALPH_TEMPLATE_TYPE '${RALPH_TEMPLATE_TYPE}', showing menu" >&2
        ;;
    esac
  fi

  cat >&2 <<'MENU'
========================================
 RalphLoop - Template Selection
========================================

Choose a template to start with:

  1) Standard Prompt
     Full project specification with goals and acceptance criteria

  2) QuickFix
     Quick bug fix or small change with minimal structure

  3) AI Enhanced Prompt
     Describe your idea and let AI generate a complete plan

  4) Load Example
     Choose from pre-built example projects

  5) Blank
     Start with an empty file

MENU

  local selection
  while true; do
    printf "Enter selection [1-5]: " >&2
    read -r selection </dev/tty
    case "$selection" in
      1) echo "standard"; return 0 ;;
      2) echo "quickfix"; return 0 ;;
      3) echo "ai"; return 0 ;;
      4) echo "example"; return 0 ;;
      5) echo "blank"; return 0 ;;
      *) echo "Invalid selection. Please enter 1-5." >&2 ;;
    esac
  done
}

# Show example selection menu and return the selected example path
show_example_menu() {
  local examples_dir="${SCRIPT_DIR:-$(dirname "${BASH_SOURCE[0]}")}/examples"
  local -a examples=()
  local i=0

  # Find all example directories with prompt.md files
  while IFS= read -r -d '' dir; do
    examples+=("$dir")
  done < <(find "$examples_dir" -maxdepth 2 -name "prompt.md" -print0 2>/dev/null | sort -z)

  if [ ${#examples[@]} -eq 0 ]; then
    echo "No examples found in $examples_dir" >&2
    echo ""
    return 1
  fi

  echo "" >&2
  echo "========================================" >&2
  echo " Available Examples" >&2
  echo "========================================" >&2
  echo "" >&2

  for ((i=0; i<${#examples[@]}; i++)); do
    local example_name
    example_name=$(dirname "${examples[$i]}" | xargs basename)
    printf "  %d) %s\n" "$((i+1))" "$example_name" >&2
  done

  echo "" >&2

  local selection
  while true; do
    printf "Enter selection [1-%d]: " "${#examples[@]}" >&2
    read -r selection </dev/tty
    if [[ "$selection" =~ ^[0-9]+$ ]] && [ "$selection" -ge 1 ] && [ "$selection" -le ${#examples[@]} ]; then
      echo "${examples[$((selection-1))]}"
      return 0
    fi
    echo "Invalid selection. Please enter 1-${#examples[@]}." >&2
  done
}

# Load an example prompt file
load_example_prompt() {
  local example_path="$1"
  if [ -f "$example_path" ]; then
    cat "$example_path"
  else
    echo "Error: Example file not found: $example_path" >&2
    return 1
  fi
}

# =============================================================================
# AI Enhanced Prompt Generation
# =============================================================================

# Call AI to generate enhanced prompt from user idea
_ai_generate_spec() {
  local user_idea="$1"
  local meta_prompt
  meta_prompt=$(cat <<METAPROMPT
You are a project specification generator. Based on the user's idea below, generate a complete project specification in markdown format.

User's Idea:
${user_idea}

Generate a specification with:
1. A clear project title
2. A detailed goal description
3. Specific, measurable acceptance criteria (use checkboxes)
4. Technical context and constraints
5. Any assumptions or prerequisites

Output ONLY the markdown specification, no explanations.
METAPROMPT
)

  local generated
  if generated=$(timeout 60 opencode run $OPENCODE_OPTS <<< "$meta_prompt" 2>/dev/null); then
    echo "$generated"
  else
    # Fallback if AI fails
    cat <<FALLBACK
# Project

## Goal
${user_idea}

## Acceptance Criteria
- [ ] Core functionality implemented
- [ ] Tests passing

## Context
[Add any additional context]
FALLBACK
  fi
}

# Show AI prompt review menu
_ai_show_review_menu() {
  echo "" >&2
  echo "========================================" >&2
  echo " Review Generated Prompt" >&2
  echo "========================================" >&2
  echo "" >&2
  echo "  a) Accept - Use this prompt as-is" >&2
  echo "  e) Edit   - Open in editor to customize" >&2
  echo "  r) Retry  - Describe your idea again" >&2
  echo "  c) Cancel - Abort and use standard template" >&2
  echo "" >&2

  local choice
  while true; do
    printf "Enter choice [a/e/r/c]: " >&2
    read -r choice </dev/tty
    case "$choice" in
      a|A) echo "accept"; return ;;
      e|E) echo "edit"; return ;;
      r|R) echo "retry"; return ;;
      c|C) echo "cancel"; return ;;
      *) echo "Invalid choice. Please enter a, e, r, or c." >&2 ;;
    esac
  done
}

# Generate an AI-enhanced prompt from user's idea
# Returns: final prompt content (accepted, edited, or fallback to standard)
generate_ai_enhanced_prompt() {
  local cache_dir idea_file edit_file editor template_content user_idea generated choice
  cache_dir=$(get_ralph_cache_dir)
  idea_file="${cache_dir}/.ai_idea_temp_$$.md"
  edit_file="${cache_dir}/.ai_edit_temp_$$.md"
  editor=$(get_editor)

  # Track the previous idea for re-prompting
  local previous_idea=""

  echo "" >&2
  echo "========================================" >&2
  echo " AI Enhanced Prompt Generator" >&2
  echo "========================================" >&2

  while true; do
    echo "" >&2
    echo "Opening editor for you to describe your idea..." >&2

    # Write idea template (with previous idea if re-prompting)
    get_ai_idea_template "$previous_idea" > "$idea_file"
    template_content=$(get_ai_idea_template "")

    # Open editor for user to write their idea
    "$editor" "$idea_file" </dev/tty >/dev/tty

    # Read the user's idea
    user_idea=$(cat "$idea_file")
    rm -f "$idea_file"

    # Check if content was modified (only for first attempt)
    if [ -z "$previous_idea" ] && [ "$user_idea" = "$template_content" ]; then
      echo "Error: Idea was not modified. Using standard template." >&2
      get_standard_template
      return 0
    fi

    # Check if empty
    if [ -z "$user_idea" ] || ! echo "$user_idea" | grep -q '[^[:space:]]'; then
      echo "Error: No idea provided. Using standard template." >&2
      get_standard_template
      return 0
    fi

    # Save for potential re-prompt
    previous_idea="$user_idea"

    echo "" >&2
    echo "Generating enhanced prompt from your idea..." >&2
    echo "" >&2

    # Generate the AI-enhanced prompt
    generated=$(_ai_generate_spec "$user_idea")

    # Display the generated prompt
    echo "========================================" >&2
    echo " Generated Prompt Preview" >&2
    echo "========================================" >&2
    echo "" >&2
    echo "$generated" >&2
    echo "" >&2
    echo "========================================" >&2

    # Show review menu
    choice=$(_ai_show_review_menu)

    case "$choice" in
      accept)
        # User accepts as-is, signal to skip editor via marker file
        touch "${cache_dir}/.ai_skip_editor_$$"
        echo "$generated"
        return 0
        ;;
      edit)
        # Open editor for final customization
        echo "$generated" > "$edit_file"
        "$editor" "$edit_file" </dev/tty >/dev/tty
        local edited
        edited=$(cat "$edit_file")
        rm -f "$edit_file"
        # Signal to skip editor via marker file
        touch "${cache_dir}/.ai_skip_editor_$$"
        echo "$edited"
        return 0
        ;;
      retry)
        # Loop back with previous idea prefilled
        echo "" >&2
        echo "Let's try again..." >&2
        continue
        ;;
      cancel)
        echo "" >&2
        echo "Cancelled. Using standard template." >&2
        get_standard_template
        return 0
        ;;
    esac
  done
}

# =============================================================================
# Cache and Session Management
# =============================================================================

# Get the Ralph cache directory for storing prompts
get_ralph_cache_dir() {
  local cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/ralph/prompts"
  mkdir -p "$cache_dir"
  echo "$cache_dir"
}

# Get the session prompt file path (stores path to current session's prompt)
get_session_prompt_marker() {
  local cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/ralph"
  mkdir -p "$cache_dir"
  echo "${cache_dir}/.session_prompt_$$"
}

# Get sanitized directory name for prompt filename
get_sanitized_dirname() {
  local dir_name
  dir_name=$(basename "$PWD")
  # Replace spaces and special chars with underscores
  echo "${dir_name//[^a-zA-Z0-9_-]/_}"
}

# =============================================================================
# Prompt Functions
# =============================================================================

# Launch user's editor to create a prompt interactively
launch_editor_for_prompt() {
  local cache_dir ts dir_name prompt_file editor original_mtime original_content new_mtime new_content
  local template_type template_content session_marker skip_editor_marker
  cache_dir=$(get_ralph_cache_dir)
  ts=$(date +%Y-%m-%d-%H%M%S)
  dir_name=$(get_sanitized_dirname)
  prompt_file="${cache_dir}/${ts}_${dir_name}.md"
  session_marker=$(get_session_prompt_marker)
  skip_editor_marker="${cache_dir}/.ai_skip_editor_$$"

  # Show template selection menu
  template_type=$(show_template_menu)

  # Get content based on selection
  case "$template_type" in
    standard)
      template_content=$(get_standard_template)
      ;;
    quickfix)
      template_content=$(get_quickfix_template)
      ;;
    ai)
      template_content=$(generate_ai_enhanced_prompt)
      ;;
    example)
      local example_path
      example_path=$(show_example_menu)
      if [ -n "$example_path" ]; then
        template_content=$(load_example_prompt "$example_path")
      else
        template_content=$(get_standard_template)
      fi
      ;;
    blank)
      template_content=$(get_blank_template)
      ;;
    *)
      template_content=$(get_standard_template)
      ;;
  esac

  # Write content to prompt file
  echo "$template_content" > "$prompt_file"

  # Check if AI flow already handled editing (skip editor marker exists)
  if [ -f "$skip_editor_marker" ]; then
    rm -f "$skip_editor_marker"
    # Store the prompt file path in session marker for reuse across iterations
    echo "$prompt_file" > "$session_marker"
    echo "Prompt saved to: $prompt_file" >&2
    cat "$prompt_file"
    return 0
  fi

  # Capture original state for modification check
  original_content=$(cat "$prompt_file")
  # stat -f %m for macOS, stat -c %Y for Linux
  original_mtime=$(stat -f %m "$prompt_file" 2>/dev/null || stat -c %Y "$prompt_file" 2>/dev/null)

  editor=$(get_editor)
  echo "" >&2
  echo "Opening editor to customize your prompt..." >&2
  echo "Prompt will be saved to: $prompt_file" >&2

  "$editor" "$prompt_file" </dev/tty >/dev/tty

  # Check if file was modified
  new_mtime=$(stat -f %m "$prompt_file" 2>/dev/null || stat -c %Y "$prompt_file" 2>/dev/null)
  new_content=$(cat "$prompt_file")

  # Fail if file wasn't saved (mtime unchanged)
  if [ "$original_mtime" = "$new_mtime" ]; then
    echo "Error: Prompt file was not saved. Aborting." >&2
    rm -f "$prompt_file"
    exit 1
  fi

  # Fail if content is unchanged from template
  if [ "$new_content" = "$original_content" ]; then
    echo "Error: Prompt file was not modified from template. Aborting." >&2
    rm -f "$prompt_file"
    exit 1
  fi

  # Fail if file is empty or only whitespace
  if [ ! -s "$prompt_file" ] || ! grep -q '[^[:space:]]' "$prompt_file"; then
    echo "Error: Prompt file is empty. Aborting." >&2
    rm -f "$prompt_file"
    exit 1
  fi

  # Store the prompt file path in session marker for reuse across iterations
  echo "$prompt_file" > "$session_marker"
  echo "Prompt saved to: $prompt_file" >&2

  cat "$prompt_file"
}

# Determine prompt source and return content
get_prompt() {
  local session_marker session_prompt_file

  # Priority 1: RALPH_PROMPT environment variable
  if [ -n "${RALPH_PROMPT:-}" ]; then
    echo "$RALPH_PROMPT"
    return
  fi

  # Priority 2: RALPH_PROMPT_FILE environment variable
  if [ -n "${RALPH_PROMPT_FILE:-}" ]; then
    if [ ! -f "$RALPH_PROMPT_FILE" ]; then
      echo "Error: RALPH_PROMPT_FILE points to a missing file: '$RALPH_PROMPT_FILE'" >&2
      exit 1
    fi
    cat "$RALPH_PROMPT_FILE"
    return
  fi

  # Priority 3: Session prompt file (created via interactive editor this session)
  session_marker=$(get_session_prompt_marker)
  if [ -f "$session_marker" ]; then
    session_prompt_file=$(cat "$session_marker")
    if [ -f "$session_prompt_file" ]; then
      cat "$session_prompt_file"
      return
    fi
  fi

  # Priority 4: Default prompt.md file
  if [ -f "$PROMPT_FILE" ]; then
    cat "$PROMPT_FILE"
    return
  fi

  # Priority 5: Launch interactive editor with template selection
  launch_editor_for_prompt
}

# Get prompt without interactive fallback (for validation)
get_prompt_nointeractive() {
  local session_marker session_prompt_file

  # Priority 1: RALPH_PROMPT environment variable
  if [ -n "${RALPH_PROMPT:-}" ]; then
    echo "$RALPH_PROMPT"
    return 0
  fi

  # Priority 2: RALPH_PROMPT_FILE environment variable
  if [ -n "${RALPH_PROMPT_FILE:-}" ] && [ -f "$RALPH_PROMPT_FILE" ]; then
    cat "$RALPH_PROMPT_FILE"
    return 0
  fi

  # Priority 3: Session prompt file (created via interactive editor this session)
  session_marker=$(get_session_prompt_marker)
  if [ -f "$session_marker" ]; then
    session_prompt_file=$(cat "$session_marker")
    if [ -f "$session_prompt_file" ]; then
      cat "$session_prompt_file"
      return 0
    fi
  fi

  # Priority 4: Default prompt.md file
  if [ -f "$PROMPT_FILE" ]; then
    cat "$PROMPT_FILE"
    return 0
  fi

  # Return default for validation context (no interactive fallback)
  echo "[No original prompt available - validate based on current state]"
  return 0
}

# Sanitize content to prevent heredoc injection
sanitize_for_heredoc() {
  local content="$1"
  echo "${content//EOF/RALPH_SAFE_EOF_MARKER}"
}

# Get validation status from result
get_validation_status() {
  local result="$1"
  echo "$result" | grep -o '<validation_status>[^<]*</validation_status>' | sed 's/<[^>]*>//g' | tr -d ' '
}

# Get validation issues from result
get_validation_issues() {
  local result="$1"
  # Extract content between <validation_issues> and </validation_issues>
  local issues
  issues=$(echo "$result" | sed -n '/<validation_issues>/,/<\/validation_issues>/p' | sed '1d;$d')
  echo "$issues"
}

# Get validation recommendations from result
get_validation_recommendations() {
  local result="$1"
  # Extract content between <validation_recommendations> and </validation_recommendations>
  local recs
  recs=$(echo "$result" | sed -n '/<validation_recommendations>/,/<\/validation_recommendations>/p' | sed '1d;$d')
  echo "$recs"
}

# Progress refactoring to prevent file from growing too large - REMOVED
# Progress file management is now delegated entirely to the AI agent.
# The agent is responsible for updating and maintaining progress.md.

# Ensure progress file exists
if [ ! -f "$PROGRESS_FILE" ]; then
  touch "$PROGRESS_FILE"
fi

# Clear previous validation issues at start
rm -f "$VALIDATION_ISSUES_FILE"

# Main loop - skip if RALPH_SOURCED_FOR_TEST is set
if [ "${RALPH_SOURCED_FOR_TEST:-0}" = "1" ]; then
    :  # Skip main loop when sourcing for testing
else
for ((i = 1; i <= MAX_ROUNDS; i++)); do
  echo "========================================"
  echo "üîÑ RalphLoop Iteration $i of $MAX_ROUNDS"
  echo "========================================"

  # Read current progress and prompt
  PROGRESS_CONTENT=$(cat "$PROGRESS_FILE")
  PROMPT_CONTENT=$(get_prompt)

  # Sanitize content to prevent heredoc injection
  SANITIZED_PROGRESS=$(sanitize_for_heredoc "$PROGRESS_CONTENT")
  SANITIZED_PROMPT=$(sanitize_for_heredoc "$PROMPT_CONTENT")

  # Check for pending validation issues from previous incomplete validation
  PENDING_ISSUES=""
  if [ -f "$VALIDATION_ISSUES_FILE" ]; then
    PENDING_ISSUES=$(cat "$VALIDATION_ISSUES_FILE")
  fi

  # Build context section with pending issues if any
  CONTEXT_SECTION=""
  if [ -n "$PENDING_ISSUES" ]; then
    CONTEXT_SECTION="
## üö® PENDING VALIDATION ISSUES FROM PREVIOUS ITERATION
The previous completion attempt failed validation. You MUST fix these issues:

${PENDING_ISSUES}

## Your Priority
Focus ONLY on resolving these validation issues. Do NOT work on new features.
After fixing, mark complete with <promise>COMPLETE</promise> for re-validation.
"
  fi

  # Build backend context section if using custom backend
  BACKEND_CONTEXT=""
  if [ -n "$RALPH_BACKEND" ]; then
    BACKEND_CONTEXT="
## üîß Backend Configuration

**Active Backend**: ${RALPH_BACKEND}
**Evaluation Mode**: ${RALPH_MODE}
**Custom Command**: ${RALPH_COMMAND:-none}

This iteration is running with backend integration. Be aware of any backend-specific requirements or constraints.
"
  fi

  # Run OpenCode agent with current context - stream output for real-time feedback
  # Timeout controlled by RALPH_TIMEOUT (default: 600 seconds)
  OUTPUT_FILE="/tmp/ralph_output_$$.txt"

  # Show progress indicator while command runs
  echo "üöÄ Starting agent execution..."
  echo "   (This may take a moment. Progress will be shown below.)"
  echo ""

  # Use tee to both save to file AND display output in real-time
  # This provides feedback while ensuring output is captured for later analysis
  set +e  # Don't exit on error during capture
  timeout "$RALPH_TIMEOUT" opencode run "$OPENCODE_OPTS" --agent AGENT_RALPH <<RALPH_EOF_XYZ123 2>&1 | tee "$OUTPUT_FILE"
# Goals and Resources

## Project plan

${SANITIZED_PROMPT}

## Current Progress

${SANITIZED_PROGRESS}
${CONTEXT_SECTION}
${BACKEND_CONTEXT}

## Your Priorities

### Phase 1: ANALYZE
1. [ ] Read and understand the project plan and acceptance criteria
2. [ ] Read progress.md to understand current state
3. [ ] Identify the highest priority next step that makes measurable progress

### Phase 2: PLAN & VALIDATE
4. [ ] Break down the goal into verifiable tasks
5. [ ] Define what "done" looks like for each task
6. [ ] Identify how you will verify completion (builds, tests, manual checks)

### Phase 3: EXECUTE & VERIFY
7. [ ] Implement the task
8. [ ] Run verification checks:
   - [ ] Code compiles/builds without errors
   - [ ] Tests pass (if applicable)
   - [ ] No linting errors
   - [ ] Changes meet acceptance criteria
9. [ ] Fix any issues found before proceeding

### Phase 4: DOCUMENT & COMMIT
10. [ ] Update progress.md with accomplishments
11. [ ] Create meaningful git commit
12. [ ] Identify next improvements

## Verification Requirements

BEFORE marking a task complete, you MUST verify:

- [ ] **Build**: Code compiles/runs successfully
- [ ] **Tests**: Unit tests pass (or state why not applicable)
- [ ] **Linting**: Code passes style checks
- [ ] **Requirements**: Feature meets acceptance criteria
- [ ] **Integration**: Works with existing code
- [ ] **No Regressions**: Existing functionality intact

## Constraints

- [ ] Only work on ONE goal per iteration
- [ ] NEVER skip verification steps
- [ ] Always run tests before committing

## Success Criteria

The loop succeeds when:

- [ ] Git history shows regular commits
- [ ] Progress tracking is current
- [ ] Verification checklist is completed
- [ ] Measurable progress made toward goal

If the current goal is complete, output <promise>COMPLETE</promise>.
RALPH_EOF_XYZ123

  # Read output from file BEFORE checking PIPESTATUS (trap may delete the file)
  result=$(cat "$OUTPUT_FILE" 2>/dev/null | tr -d '\0' || echo "")

  # Get exit code from timeout/opencode command
  EXIT_CODE=${PIPESTATUS[0]}
  set -e  # Re-enable exit on error

  # Check if timeout or error occurred
  if [ "$EXIT_CODE" -eq 124 ]; then
    {
      echo "‚ùå TIMEOUT: opencode command exceeded ${RALPH_TIMEOUT}s ($((RALPH_TIMEOUT / 60)) minutes) - killed to prevent memory issues"
      echo "This may indicate the agent is stuck or consuming too much memory."
      echo "üí° Tip: Increase timeout with: export RALPH_TIMEOUT=$((RALPH_TIMEOUT * 2))"
    } >> "$OUTPUT_FILE"
  elif [ "$EXIT_CODE" -ne 0 ]; then
    echo "‚ùå ERROR: opencode command failed with exit code $EXIT_CODE" >> "$OUTPUT_FILE"
  fi

  # Check if result is empty or indicates an error
  if [ -z "$result" ]; then
    echo "‚ö†Ô∏è WARNING: Empty output from opencode agent - may indicate memory or execution issue"
    rm -f "$OUTPUT_FILE"
    echo "Continuing to next iteration..."
    echo ""
    continue
  fi

  # Output has already been streamed via tee, just show separator
  echo ""
  echo "--- Output complete ---"
  rm -f "$OUTPUT_FILE"

  # Check for completion
  if echo "$result" | grep -q "<promise>COMPLETE</promise>"; then
    echo ""
    echo "üõ°Ô∏è Goal marked complete. Running independent validation..."
    echo "========================================"

    # Run validation prompt to verify completion criteria are truly met - stream output for real-time feedback
    # Timeout controlled by RALPH_TIMEOUT (default: 600 seconds)
    VALIDATION_OUTPUT_FILE="/tmp/ralph_validation_$$.txt"

    echo "üõ°Ô∏è Running independent validation..."
    echo ""

    # Use tee to both save to file AND display output in real-time
    set +e  # Don't exit on error during capture
    timeout "$RALPH_TIMEOUT" opencode run "$OPENCODE_OPTS" --agent AGENT_RALPH <<RALPH_VALIDATE_EOF 2>&1 | tee "$VALIDATION_OUTPUT_FILE"
# Validation Task

The agent previously indicated completion with <promise>COMPLETE</promise>.

You must INDEPENDENTLY VERIFY that all acceptance criteria are actually met.

## Original Project Goal (from prompt.md):
$(get_prompt_nointeractive)

## Current Progress:
$(cat "$PROGRESS_FILE")

## Your Validation Task:

1. READ the current state
2. CHECK each acceptance criterion is actually satisfied:
   - For each requirement, verify it exists and works
   - Run tests, build commands, and manual checks
3. VERIFY git history shows meaningful commits
4. RUN comprehensive verification:
   - [ ] Code compiles/builds without errors (run: npm run build or equivalent)
   - [ ] Tests pass (run: npm test or equivalent)
   - [ ] No linting errors (run: npm run lint or equivalent)
   - [ ] All acceptance criteria from prompt.md are met
   - [ ] No regressions in existing functionality
5. OUTPUT your findings in this exact XML format:

<validation_status>PASS</validation_status> or <validation_status>FAIL</validation_status>

<validation_issues>
- [List each failing criterion with specific details]
- Leave empty if PASS
</validation_issues>

<validation_recommendations>
- [Specific actions needed to fix each issue]
- Leave empty if PASS
</validation_recommendations>

IMPORTANT:
- If ALL checks pass, use <validation_status>PASS</validation_status>
- If ANY check fails, use <validation_status>FAIL</validation_status> and list all issues
- Do NOT trust the previous agent's assessment. Verify independently.
RALPH_VALIDATE_EOF

    VALIDATION_EXIT_CODE=${PIPESTATUS[0]}  # Get exit code from timeout/opencode command
    set -e  # Re-enable exit on error

    # Check if timeout or error occurred
    if [ "$VALIDATION_EXIT_CODE" -eq 124 ]; then
      {
        echo "‚ùå VALIDATION TIMEOUT: exceeded ${RALPH_TIMEOUT}s ($((RALPH_TIMEOUT / 60)) minutes)"
        echo "<validation_status>FAIL</validation_status>"
        echo "<validation_issues>"
        echo "- Validation timed out after ${RALPH_TIMEOUT}s ($((RALPH_TIMEOUT / 60)) minutes)"
        echo "- Increase timeout with: export RALPH_TIMEOUT=$((RALPH_TIMEOUT * 2))"
        echo "</validation_issues>"
      } >> "$VALIDATION_OUTPUT_FILE"
    elif [ "$VALIDATION_EXIT_CODE" -ne 0 ]; then
      echo "‚ùå VALIDATION ERROR: failed with exit code $VALIDATION_EXIT_CODE" >> "$VALIDATION_OUTPUT_FILE"
    fi

    validation_result=$(cat "$VALIDATION_OUTPUT_FILE" | tr -d '\0')
    rm -f "$VALIDATION_OUTPUT_FILE"

    # Output has already been streamed via tee, just show completion message
    echo ""
    echo "--- Validation complete ---"

    echo ""
    echo "üìã Validation Results:"
    echo "-----------------------------------"
    echo "$validation_result"
    echo "-----------------------------------"

    # Extract and check validation status
    VALIDATION_STATUS=$(get_validation_status "$validation_result")

    if [ "$VALIDATION_STATUS" = "PASS" ]; then
      echo ""
      echo "üéâ Validation PASSED! RalphLoop mission complete!"
      echo "========================================"
      # Progress file management is delegated to the AI agent
      rm -f "$VALIDATION_ISSUES_FILE"
      exit 0
    else
      echo ""
      echo "‚ö†Ô∏è Validation FAILED. Saving issues for next iteration..."
      # Extract and save validation issues
      ISSUES=$(get_validation_issues "$validation_result")
      RECOMMENDATIONS=$(get_validation_recommendations "$validation_result")

      # Combine issues and recommendations for the next iteration
      {
        echo "## Issues Found:"
        echo "$ISSUES"
        echo ""
        echo "## Recommendations:"
        echo "$RECOMMENDATIONS"
      } >"$VALIDATION_ISSUES_FILE"

      echo "Issues saved to ${VALIDATION_ISSUES_FILE}"
      echo "Agent will prioritize fixing these in next iteration."
      echo ""
    fi
  fi

  echo ""
  echo "‚úÖ Iteration $i complete. Continuing..."
  echo ""
done

  echo "========================================"
  echo "üèÅ Max iterations ($MAX_ROUNDS) reached."
  echo "   RalphLoop will rest for now."
  echo "========================================"
fi
