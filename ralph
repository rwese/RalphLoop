#!/usr/bin/env bash

# ralph - RalphLoop Autonomous Development Agent
# Usage: ./ralph [options] [iterations]
#
# Options:
#   --sessions           List all sessions
#   --resume <id>        Resume a specific session
#   --cleanup [days]     Clean up incomplete sessions older than N days (default: 7)
#   --cleanup-all        Clean up ALL incomplete sessions
#   -h, --help           Show this help message
#
# Prompt can be provided via:
# 1. prompt.md file (default)
# 2. RALPH_PROMPT environment variable (direct prompt text)
# 3. RALPH_PROMPT_FILE environment variable (path to prompt file)
#
# Custom commands can trigger evaluation loops via:
# - RALPH_COMMAND: Execute a specific command mode
# - RALPH_BACKEND: Use a specific backend configuration
# - RALPH_MODE: Set evaluation mode (autonomous, interactive, validation)
#
# Supported custom commands:
#   ralf-trigger --iterations N --mode MODE --backend BACKEND
#   ralf-status [--progress] [--state] [--backends]
#   ralf-config [--get key] [--set key=value] [--list]
#
# Environment variables:
#   RALPH_TIMEOUT       - Timeout for opencode commands in seconds (default: 1800 = 30 minutes)
#   RALPH_MEMORY_LIMIT  - Memory limit in KB (default: 4194304 = 4GB)
#   RALPH_LOG_LEVEL     - OpenCode log level: DEBUG, INFO, WARN, ERROR (default: WARN)
#   RALPH_PRINT_LOGS    - Print opencode logs to stderr: true/false (default: false)
#   RALPH_PROMPT        - Direct prompt text
#   RALPH_PROMPT_FILE   - Path to prompt file
#   RALPH_COMMAND       - Custom command to execute
#   RALPH_BACKEND       - Backend to use
#   RALPH_MODE          - Mode: autonomous, interactive, validation
#   RALPH_SOURCED_FOR_TEST - Internal: set to 1 when sourcing for testing

set -e -u -o pipefail

# Configuration
MAX_ROUNDS=${1:-${MAX_ROUNDS:-100}}
TEMP_FILE="$(mktemp)"
TEMP_FILE_PREFIX="${TEMP_FILE}_ralph"
PROGRESS_FILE="${TEMP_FILE_PREFIX}_progress.md"
PROMPT_FILE="${TEMP_FILE_PREFIX}_prompt.md"
VALIDATION_ISSUES_FILE="${TEMP_FILE_PREFIX}_issues.md"
OUTPUT_FILE="${TEMP_FILE_PREFIX}_output.txt"

BACKENDS_DIR="backends"

# Timeout and memory configuration (customizable via environment)
RALPH_TIMEOUT=${RALPH_TIMEOUT:-1800}              # Default: 30 minutes in seconds
RALPH_MEMORY_LIMIT=${RALPH_MEMORY_LIMIT:-4194304} # Default: 4GB in KB

# OpenCode logging configuration
RALPH_LOG_LEVEL=${RALPH_LOG_LEVEL:-WARN}    # Default: WARN to avoid too much output
RALPH_PRINT_LOGS=${RALPH_PRINT_LOGS:-false} # Default: false (logs to file instead)

# Note: Progress file management is delegated entirely to the AI agent.
# The agent is responsible for updating and maintaining progress.md.

# Session tracking (initialized before trap)
SESSION_ID=""
RESUME_ORIGINAL_DIR=""
OPENCODE_PID=""       # PID of background opencode process for signal handling
PROMPT_ACCEPTED=false # Flag to track if prompt has been accepted

# Ralph's execution context - added to user's prompt at runtime
RALPH_PROMPTS='
## Your Priorities

### Phase 1: ANALYZE
1. [ ] Read and understand the project plan and acceptance criteria
2. [ ] Read progress.md to understand current state
3. [ ] Identify the highest priority next step that makes measurable progress

### Phase 2: PLAN & VALIDATE
4. [ ] Break down the goal into verifiable tasks
5. [ ] Define what "done" looks like for each task
6. [ ] Identify how you will verify completion (builds, tests, manual checks)

### Phase 3: EXECUTE & VERIFY
7. [ ] Implement the task
8. [ ] Run verification checks:
   - [ ] Code compiles/builds without errors
   - [ ] Tests pass (if applicable)
   - [ ] No linting errors
   - [ ] Changes meet acceptance criteria
9. [ ] Fix any issues found before proceeding

### Phase 4: DOCUMENT & COMMIT
10. [ ] Update progress.md with accomplishments
11. [ ] Create meaningful git commit
12. [ ] Identify next improvements

## Verification Requirements

BEFORE marking a task complete, you MUST verify:

- [ ] **Build**: Code compiles/runs successfully
- [ ] **Tests**: Unit tests pass (or state why not applicable)
- [ ] **Linting**: Code passes style checks
- [ ] **Requirements**: Feature meets acceptance criteria
- [ ] **Integration**: Works with existing code
- [ ] **No Regressions**: Existing functionality intact

## Constraints

- [ ] Only work on ONE goal per iteration
- [ ] NEVER skip verification steps
- [ ] Always run tests before committing

## Success Criteria

The loop succeeds when:

- [ ] Git history shows regular commits
- [ ] Progress tracking is current
- [ ] Verification checklist is completed
- [ ] Measurable progress made toward goal

If the current goal is complete, output <promise>COMPLETE</promise>
'

# Cleanup function for graceful termination
# This function handles SIGINT (Ctrl+C) and SIGTERM signals
# It ensures the opencode process is properly terminated and temp files are cleaned up
cleanup() {
  echo "" >&2
  echo "üõë Caught signal - initiating graceful shutdown..." >&2

  # Kill opencode process if running
  if [ -n "$OPENCODE_PID" ] && kill -0 "$OPENCODE_PID" 2>/dev/null; then
    echo "   Terminating opencode process (PID: $OPENCODE_PID)..." >&2
    kill -TERM "$OPENCODE_PID" 2>/dev/null || true

    # Wait briefly for graceful shutdown, then force kill if still running
    local count=0
    while kill -0 "$OPENCODE_PID" 2>/dev/null && [ $count -lt 5 ]; do
      sleep 1
      count=$((count + 1))
    done

    # Force kill if process is still running after 5 seconds
    if kill -0 "$OPENCODE_PID" 2>/dev/null; then
      echo "   Process still running - sending SIGKILL..." >&2
      kill -9 "$OPENCODE_PID" 2>/dev/null || true
    fi
  fi

  # Clean up temp files
  echo "   Cleaning up temporary files..." >&2
  rm -f "${TEMP_FILE_PREFIX}"* 2>/dev/null || true

  # Save session state if we have one AND prompt was accepted OR session already existed
  if [ -n "$SESSION_ID" ] && [ "$PROMPT_ACCEPTED" = true ]; then
    echo "   Saving session state..." >&2
    save_session "$SESSION_ID" 0 "$MAX_ROUNDS" 2>/dev/null || true
  elif [ -n "$SESSION_ID" ] && [ -d "$(get_session_dir "$SESSION_ID")" ]; then
    # Also save if session directory already exists (resumed sessions)
    echo "   Saving existing session state..." >&2
    save_session "$SESSION_ID" 0 "$MAX_ROUNDS" 2>/dev/null || true
  fi

  echo "   Shutdown complete." >&2
}

# Trap SIGINT (Ctrl+C) and SIGTERM for graceful cleanup
# Exit code 130 = 128 + 2 (SIGINT signal number)
trap 'cleanup; exit 130' INT TERM

# =============================================================================
# Command-line Arguments
# =============================================================================

# Parse command-line arguments
RALPH_RESUME=""
RALPH_SESSIONS=false
RALPH_CLEANUP=""
RALPH_CLEANUP_DAYS=7

while [[ $# -gt 0 ]]; do
  case "$1" in
  --sessions)
    RALPH_SESSIONS=true
    shift
    ;;
  --resume)
    if [[ -z "$2" || "$2" == --* ]]; then
      echo "Error: --resume requires a session ID argument"
      exit 1
    fi
    RALPH_RESUME="$2"
    shift 2
    ;;
  --cleanup)
    if [[ -n "$2" && "$2" != --* ]]; then
      if [[ "$2" =~ ^[0-9]+$ ]]; then
        RALPH_CLEANUP_DAYS="$2"
      else
        echo "Warning: Invalid argument for --cleanup, using default of 7 days"
      fi
      shift
    else
      RALPH_CLEANUP="$RALPH_CLEANUP_DAYS"
    fi
    shift
    ;;
  --cleanup-all)
    RALPH_CLEANUP="all"
    shift
    ;;
  -h | --help)
    cat <<EOF
RalphLoop - Autonomous Development Agent

Usage: ./ralph [options] [iterations]

Options:
  --sessions           List all sessions
  --resume <id>        Resume a specific session
  --cleanup [days]     Clean up incomplete sessions older than N days (default: 7)
  --cleanup-all        Clean up ALL incomplete sessions
  -h, --help           Show this help message

Session Management:
  Sessions are automatically saved and can be resumed after interruption.
  Session files are stored in ~/.cache/ralph/sessions/

Examples:
  ./ralph 10                  Run 10 iterations
  ./ralph --sessions          List all sessions
  ./ralph --resume myproject_20240123-143000
  ./ralph --cleanup 3         Clean up incomplete sessions older than 3 days
EOF
    exit 0
    ;;
  *)
    # Not a known option, stop parsing
    break
    ;;
  esac
done

# =============================================================================
# Cache and Session Management Functions
# =============================================================================

# Get the Ralph cache directory for storing prompts
get_ralph_cache_dir() {
  local cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/ralph/prompts"
  mkdir -p "$cache_dir"
  echo "$cache_dir"
}

# Get the Ralph sessions directory
get_ralph_sessions_dir() {
  local sessions_dir="${XDG_CACHE_HOME:-$HOME/.cache}/ralph/sessions"
  mkdir -p "$sessions_dir"
  echo "$sessions_dir"
}

# Get sanitized directory name for session filename
get_sanitized_dirname() {
  local dir_name
  dir_name=$(basename "$PWD")
  # Replace spaces and special chars with underscores
  echo "${dir_name//[^a-zA-Z0-9_-]/_}"
}

# Generate a unique session ID based on directory and timestamp
generate_session_id() {
  local dir_name
  dir_name=$(get_sanitized_dirname)
  local ts
  ts=$(date +%Y%m%d-%H%M%S)
  echo "${dir_name}_${ts}"
}

# Get session directory for a specific session ID
get_session_dir() {
  local session_id="$1"
  local sessions_dir
  sessions_dir=$(get_ralph_sessions_dir)
  echo "${sessions_dir}/${session_id}"
}

# Save current session state
save_session() {
  local session_id="$1"
  local iteration="$2"
  local max_iterations="$3"
  local user_prompt_file="${4:-}" # Optional: path to user's original prompt
  local session_dir created_at

  session_dir=$(get_session_dir "$session_id")
  mkdir -p "$session_dir"

  # Preserve original creation time if session already exists
  if [ -f "${session_dir}/session.json" ]; then
    created_at=$(grep '"created_at"' "${session_dir}/session.json" | sed 's/.*"\([^"]*\)".*/\1/')
  else
    created_at=$(date -Iseconds)
  fi

  # Save session metadata
  cat >"${session_dir}/session.json" <<EOF
{
  "session_id": "${session_id}",
  "directory": "${PWD}",
  "created_at": "${created_at}",
  "iteration": ${iteration},
  "max_iterations": ${max_iterations},
  "status": "incomplete"
}
EOF

  # Save user's original prompt (pure, unmodified)
  if [ -n "$user_prompt_file" ] && [ -f "$user_prompt_file" ]; then
    cp "$user_prompt_file" "${session_dir}/prompt.md"
  fi

  # Save Ralph's prompts separately (for transparency and resuming)
  if [ -n "${RALPH_PROMPTS:-}" ]; then
    echo "$RALPH_PROMPTS" >"${session_dir}/ralph-prompts.md"
  fi

  # Save progress file
  if [ -f "$PROGRESS_FILE" ]; then
    cp "$PROGRESS_FILE" "${session_dir}/progress.md"
  fi

  # Save validation issues separately
  if [ -f "$VALIDATION_ISSUES_FILE" ]; then
    cp "$VALIDATION_ISSUES_FILE" "${session_dir}/issues.md"
  fi

  # Create incomplete marker
  touch "${session_dir}/.incomplete"

  echo "üíæ Session saved: $session_id"
}

# Mark session as complete
complete_session() {
  local session_id="$1"
  local session_dir
  session_dir=$(get_session_dir "$session_id")

  if [ -d "$session_dir" ]; then
    rm -f "${session_dir}/.incomplete"
    # Update status metadata
    if [ -f "${session_dir}/session.json" ]; then
      sed -i 's/"status": "incomplete"/"status": "complete"/' "${session_dir}/session.json" 2>/dev/null ||
        sed -i '' 's/"status": "incomplete"/"status": "complete"/' "${session_dir}/session.json"
    fi
    echo "‚úÖ Session completed: $session_id"
  fi
}

# Mark session as failed
fail_session() {
  local session_id="$1"
  local session_dir
  session_dir=$(get_session_dir "$session_id")

  if [ -d "$session_dir" ]; then
    # Update status in metadata
    if [ -f "${session_dir}/session.json" ]; then
      sed -i 's/"status": "incomplete"/"status": "failed"/' "${session_dir}/session.json" 2>/dev/null ||
        sed -i '' 's/"status": "incomplete"/"status": "failed"/' "${session_dir}/session.json"
    fi
    echo "‚ùå Session failed: $session_id"
  fi
}

# List all sessions
list_sessions() {
  local sessions_dir
  sessions_dir=$(get_ralph_sessions_dir)

  if [ ! -d "$sessions_dir" ] || [ -z "$(ls -A "$sessions_dir" 2>/dev/null)" ]; then
    echo "No sessions found."
    return 0
  fi

  echo "========================================"
  echo "üìÇ RalphLoop Sessions"
  echo "========================================"
  echo ""

  local count=0
  while IFS= read -r session_dir; do
    local session_id
    session_id=$(basename "$session_dir")

    # Read session metadata
    local status="unknown"
    local iteration="?"
    local directory="?"
    local created="?"

    if [ -f "${session_dir}/session.json" ]; then
      status=$(grep '"status"' "${session_dir}/session.json" | sed 's/.*: *"\([^"]*\)".*/\1/')
      iteration=$(grep '"iteration"' "${session_dir}/session.json" | sed 's/.*: *\([0-9]*\).*/\1/')
      directory=$(grep '"directory"' "${session_dir}/session.json" | sed 's/.*: *"\([^"]*\)".*/\1/')
      created=$(grep '"created_at"' "${session_dir}/session.json" | sed 's/.*: *"\([^"]*\)".*/\1/' | cut -d'T' -f1)
    fi

    # Check for incomplete marker
    local incomplete_marker=""
    if [ -f "${session_dir}/.incomplete" ]; then
      incomplete_marker=" [INCOMPLETE]"
    fi

    # Status icon
    local icon="üìÑ"
    case "$status" in
    complete) icon="‚úÖ" ;;
    failed) icon="‚ùå" ;;
    incomplete) icon="‚è≥" ;;
    esac

    printf "%s %s%s\n" "$icon" "$session_id" "$incomplete_marker"
    printf "   üìÅ %s\n" "$directory"
    printf "   üìä Iteration: %s | Created: %s\n" "$iteration" "$created"
    echo ""

    count=$((count + 1))
  done < <(find "$sessions_dir" -mindepth 1 -maxdepth 1 -type d | sort -r)

  echo "-----------------------------------"
  echo "Total sessions: $count"
  echo ""
  echo "Resume a session: ./ralph --resume <session_id>"
  echo "Clean up sessions: ./ralph --cleanup"
}

# Cleanup old sessions (remove incomplete ones older than specified days)
cleanup_sessions() {
  local days="${1:-7}"
  local sessions_dir
  sessions_dir=$(get_ralph_sessions_dir)

  if [ ! -d "$sessions_dir" ]; then
    echo "No sessions to clean up."
    return 0
  fi

  local count=0
  local deleted=0

  while IFS= read -r session_dir; do
    local session_id
    session_id=$(basename "$session_dir")

    # Only remove incomplete sessions
    if [ -f "${session_dir}/.incomplete" ]; then
      # Check age
      local age
      age=$(find "$session_dir" -type f -mtime +${days} 2>/dev/null | wc -l)

      if [ "$age" -gt 0 ]; then
        rm -rf "$session_dir"
        echo "üóëÔ∏è  Deleted incomplete session: $session_id (older than ${days} days)"
        deleted=$((deleted + 1))
      fi
    fi

    count=$((count + 1))
  done < <(find "$sessions_dir" -mindepth 1 -maxdepth 1 -type d 2>/dev/null)

  echo ""
  echo "Cleaned up $deleted incomplete sessions."
}

# Resume a specific session
resume_session() {
  local session_id="$1"
  local session_dir
  session_dir=$(get_session_dir "$session_id")

  if [ ! -d "$session_dir" ]; then
    echo "‚ùå Session not found: $session_id"
    return 1
  fi

  if [ ! -f "${session_dir}/session.json" ]; then
    echo "‚ùå Session metadata not found: $session_id"
    return 1
  fi

  # Read session metadata
  local iteration max_iterations directory
  iteration=$(grep '"iteration"' "${session_dir}/session.json" | sed 's/.*: *\([0-9]*\).*/\1/')
  max_iterations=$(grep '"max_iterations"' "${session_dir}/session.json" | sed 's/.*: *\([0-9]*\).*/\1/')
  directory=$(grep '"directory"' "${session_dir}/session.json" | sed 's/.*: *"\([^"]*\)".*/\1/')

  # Save original directory globally for later use
  RESUME_ORIGINAL_DIR="$directory"

  # Check if we're in the right directory
  if [ "$directory" != "$(pwd)" ]; then
    echo "‚ö†Ô∏è  Warning: Session was created in different directory:" >&2
    echo "   Session: $directory" >&2
    echo "   Current: $(pwd)" >&2
    echo "" >&2
    echo "You may need to cd to the correct directory first." >&2
    echo "" >&2
  fi

  # Restore files to temp locations
  # Copy prompt file if it exists in session dir
  if [ -f "${session_dir}/prompt.md" ]; then
    cp "${session_dir}/prompt.md" "${TEMP_FILE_PREFIX}_prompt.md"
  elif [ -f "${directory}/prompt.md" ]; then
    # Fallback: copy from original session directory
    cp "${directory}/prompt.md" "${TEMP_FILE_PREFIX}_prompt.md"
  fi

  if [ -f "${session_dir}/progress.md" ]; then
    cp "${session_dir}/progress.md" "$PROGRESS_FILE"
  fi

  if [ -f "${session_dir}/issues.md" ]; then
    cp "${session_dir}/issues.md" "$VALIDATION_ISSUES_FILE"
  fi

  echo "üîÑ Resuming session: $session_id" >&2
  echo "   Directory: $directory" >&2
  echo "   Starting from iteration: $iteration" >&2
  echo "   Max iterations: $max_iterations" >&2
  echo "" >&2

  # Return the iteration to resume from
  echo "$iteration"
}

# Check for incomplete sessions in current directory
check_incomplete_sessions() {
  local sessions_dir
  sessions_dir=$(get_ralph_sessions_dir)
  local current_dir
  current_dir=$(pwd)
  local found=0

  if [ ! -d "$sessions_dir" ]; then
    return 1
  fi

  while IFS= read -r session_dir; do
    local session_id
    session_id=$(basename "$session_dir")

    # Check if this session is for the current directory and is incomplete
    if [ -f "${session_dir}/.incomplete" ] && grep -q "\"directory\": *\"${current_dir}\"" "${session_dir}/session.json" 2>/dev/null; then
      if [ "$found" -eq 0 ]; then
        echo "========================================"
        echo "‚ö†Ô∏è  Incomplete session(s) found!"
        echo "========================================"
        echo ""
        found=1
      fi

      local iteration
      iteration=$(grep '"iteration"' "${session_dir}/session.json" | sed 's/.*: *\([0-9]*\).*/\1/')
      printf "  üîÑ %s (iteration %s)\n" "$session_id" "$iteration"
    fi
  done < <(find "$sessions_dir" -mindepth 1 -maxdepth 1 -type d 2>/dev/null)

  if [ "$found" -eq 1 ]; then
    echo ""
    echo "Resume with: ./ralph --resume <session_id>"
    echo "Or list all: ./ralph --sessions"
    return 0
  fi

  return 1
}

# Get the session prompt file path (stores path to current session's prompt)
get_session_prompt_marker() {
  local cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/ralph"
  mkdir -p "$cache_dir"
  echo "${cache_dir}/.session_prompt_$$"
}

# Get the user's preferred editor
get_editor() {
  if [ -n "${VISUAL:-}" ]; then
    echo "$VISUAL"
  elif [ -n "${EDITOR:-}" ]; then
    echo "$EDITOR"
  else
    echo "vi"
  fi
}

# Handle session management commands
if [ "$RALPH_SESSIONS" = "true" ]; then
  list_sessions
  exit 0
fi

if [ -n "$RALPH_CLEANUP" ]; then
  cleanup_sessions "$RALPH_CLEANUP"
  exit 0
fi

if [ -n "$RALPH_RESUME" ]; then
  RESUME_ITERATION=$(resume_session "$RALPH_RESUME")
  if [ $? -eq 0 ] && [ -n "$RESUME_ITERATION" ]; then
    # Use the existing session ID for the resumed session
    SESSION_ID="$RALPH_RESUME"

    # Mark prompt as accepted for resumed sessions (session already exists on disk)
    PROMPT_ACCEPTED=true

    # Update MAX_ROUNDS to continue from where we left off
    # Ensure MAX_ROUNDS is numeric first (re-initialize from default if needed)
    if [[ -z "$MAX_ROUNDS" || ! "$MAX_ROUNDS" =~ ^[0-9]+$ ]]; then
      MAX_ROUNDS=100
    fi
    MAX_ROUNDS=$((MAX_ROUNDS + RESUME_ITERATION - 1))
    echo "   Continuing from iteration $RESUME_ITERATION (total: $MAX_ROUNDS)"
  else
    exit 1
  fi
  echo ""
fi

# Reset positional parameters to remaining arguments (iterations count)
set -- "$@"

# Build opencode command with logging options
OPENCODE_OPTS=()
if [ -n "$RALPH_LOG_LEVEL" ]; then
  OPENCODE_OPTS+=("--log-level" "$RALPH_LOG_LEVEL")
fi
if [ "$RALPH_PRINT_LOGS" = "true" ]; then
  OPENCODE_OPTS+=("--print-logs")
fi
OPENCODE_OPTS+=("--agent" "${RALPH_AGENT:-AGENT_RALPH}")

# Custom command configuration
RALPH_COMMAND="${RALPH_COMMAND:-}"
RALPH_BACKEND="${RALPH_BACKEND:-}"
RALPH_MODE="${RALPH_MODE:-autonomous}"

# Handle custom command mode
handle_custom_command() {
  if [[ -n "$RALPH_COMMAND" ]]; then
    echo "========================================"
    echo "üîß Custom Command Mode: $RALPH_COMMAND"
    echo "========================================"
    echo "  Backend: ${RALPH_BACKEND:-default}"
    echo "  Mode: $RALPH_MODE"
    echo "========================================"

    # Export backend and mode for the agent
    export RALPH_BACKEND="$RALPH_BACKEND"
    export RALPH_MODE="$RALPH_MODE"
  fi
}

# Load backend configuration if available
load_backend_config() {
  if [[ -n "$RALPH_BACKEND" ]]; then
    local backend_config="${BACKENDS_DIR}/${RALPH_BACKEND}/config.json"
    if [[ -f "$backend_config" ]]; then
      echo "üì¶ Loading backend configuration: $RALPH_BACKEND"

      # Load backend-specific settings if jq is available
      if command -v jq &>/dev/null; then
        local backend_enabled
        backend_enabled=$(jq -r '.enabled // false' "$backend_config" 2>/dev/null || echo "false")

        if [[ "$backend_enabled" == "true" ]]; then
          echo "‚úÖ Backend '$RALPH_BACKEND' enabled and configured"
        else
          echo "‚ö†Ô∏è Backend '$RALPH_BACKEND' is disabled in configuration"
        fi
      fi
    else
      echo "‚ö†Ô∏è Backend configuration not found: $backend_config"
    fi
  fi
}

# Initialize custom command support
handle_custom_command
load_backend_config

# Display configuration info
display_config() {
  echo "========================================"
  echo "‚öôÔ∏è  RalphLoop Configuration"
  echo "========================================"
  echo "  Timeout:        ${RALPH_TIMEOUT}s ($((RALPH_TIMEOUT / 60)) minutes)"
  echo "  Memory Limit:   ${RALPH_MEMORY_LIMIT}KB ($((RALPH_MEMORY_LIMIT / 1024 / 1024))GB)"
  echo "  Log Level:      $RALPH_LOG_LEVEL"
  echo "  Print Logs:     $RALPH_PRINT_LOGS"
  echo "  Max Iterations: $MAX_ROUNDS"
  if [ -n "$RALPH_BACKEND" ]; then
    echo "  Backend:        $RALPH_BACKEND"
    echo "  Mode:           $RALPH_MODE"
  fi
  echo "========================================"
}
# Display configuration info (only when not sourcing for tests)
if [ "${RALPH_SOURCED_FOR_TEST:-0}" != "1" ]; then
  display_config
fi

# Validate MAX_ROUNDS is a positive integer
validate_max_rounds() {
  if ! [[ "$MAX_ROUNDS" =~ ^[0-9]+$ ]]; then
    echo "Error: MAX_ROUNDS must be a positive integer, got: '$MAX_ROUNDS'" >&2
    exit 1
  fi
  if [ "$MAX_ROUNDS" -eq 0 ]; then
    echo "Error: MAX_ROUNDS must be greater than 0" >&2
    exit 1
  fi
}

# Skip initialization when sourcing for testing
if [ "${RALPH_SOURCED_FOR_TEST:-0}" != "1" ]; then
  validate_max_rounds
fi

# =============================================================================
# Template Functions
# =============================================================================

# Get the standard prompt template
get_standard_template() {
  cat <<'TEMPLATE'
# Project Goal

[Describe what you want to accomplish]

## Acceptance Criteria

- [ ] Criterion 1
- [ ] Criterion 2

## Context

[Any additional context, constraints, or preferences]
TEMPLATE
}

# Get the quickfix template for small changes
get_quickfix_template() {
  cat <<'TEMPLATE'
# QuickFix

## Issue
[Describe the bug or small change needed]

## Expected Behavior
[What should happen after the fix]

## Files Affected
- [ ] File 1

## Acceptance Criteria
- [ ] The fix is implemented
- [ ] No regressions introduced
TEMPLATE
}

# Get blank template
get_blank_template() {
  cat <<'TEMPLATE'
# Project

TEMPLATE
}

# Get the AI idea template (with optional prefilled content)
get_ai_idea_template() {
  local prefill="${1:-}"
  if [ -n "$prefill" ]; then
    echo "$prefill"
  else
    cat <<'TEMPLATE'
# Describe Your Project Idea

Write a brief description of what you want to build or accomplish.
The AI will expand this into a full project specification.

## Your Idea

[Replace this with your project idea - be as detailed or brief as you like]

## Optional: Additional Context

[Any constraints, preferences, or technical requirements]
TEMPLATE
  fi
}

# =============================================================================
# Template Selection Menu
# =============================================================================

# Show template selection menu and return the selected type
show_template_menu() {
  # Check for environment variable override
  if [ -n "${RALPH_TEMPLATE_TYPE:-}" ]; then
    case "${RALPH_TEMPLATE_TYPE}" in
    standard | quickfix | ai | example | blank)
      echo "${RALPH_TEMPLATE_TYPE}"
      return 0
      ;;
    *)
      echo "Warning: Invalid RALPH_TEMPLATE_TYPE '${RALPH_TEMPLATE_TYPE}', showing menu" >&2
      ;;
    esac
  fi

  cat >&2 <<'MENU'
========================================
 RalphLoop - Template Selection
========================================

Choose a template to start with:

  1) Standard Prompt
     Full project specification with goals and acceptance criteria

  2) QuickFix
     Quick bug fix or small change with minimal structure

  3) AI Enhanced Prompt
     Describe your idea and let AI generate a complete plan

  4) Load Example
     Choose from pre-built example projects

  5) Blank
     Start with an empty file

MENU

  local selection
  while true; do
    printf "Enter selection [1-5]: " >&2
    read -r selection </dev/tty
    case "$selection" in
    1)
      echo "standard"
      return 0
      ;;
    2)
      echo "quickfix"
      return 0
      ;;
    3)
      echo "ai"
      return 0
      ;;
    4)
      echo "example"
      return 0
      ;;
    5)
      echo "blank"
      return 0
      ;;
    *) echo "Invalid selection. Please enter 1-5." >&2 ;;
    esac
  done
}

# Show example selection menu and return the selected example path
show_example_menu() {
  local examples_dir="${SCRIPT_DIR:-$(dirname "${BASH_SOURCE[0]}")}/examples"
  local -a examples=()
  local i=0

  # Find all example directories with prompt.md files
  while IFS= read -r -d '' dir; do
    examples+=("$dir")
  done < <(find "$examples_dir" -maxdepth 2 -name "prompt.md" -print0 2>/dev/null | sort -z)

  if [ ${#examples[@]} -eq 0 ]; then
    echo "No examples found in $examples_dir" >&2
    echo ""
    return 1
  fi

  echo "" >&2
  echo "========================================" >&2
  echo " Available Examples" >&2
  echo "========================================" >&2
  echo "" >&2

  for ((i = 0; i < ${#examples[@]}; i++)); do
    local example_name
    example_name=$(dirname "${examples[$i]}" | xargs basename)
    printf "  %d) %s\n" "$((i + 1))" "$example_name" >&2
  done

  echo "" >&2

  local selection
  while true; do
    printf "Enter selection [1-%d]: " "${#examples[@]}" >&2
    read -r selection </dev/tty
    if [[ "$selection" =~ ^[0-9]+$ ]] && [ "$selection" -ge 1 ] && [ "$selection" -le ${#examples[@]} ]; then
      echo "${examples[$((selection - 1))]}"
      return 0
    fi
    echo "Invalid selection. Please enter 1-${#examples[@]}." >&2
  done
}

# Load an example prompt file
load_example_prompt() {
  local example_path="$1"
  if [ -f "$example_path" ]; then
    cat "$example_path"
  else
    echo "Error: Example file not found: $example_path" >&2
    return 1
  fi
}

# =============================================================================
# AI Enhanced Prompt Generation
# =============================================================================

# Call AI to generate enhanced prompt from user idea
_ai_generate_spec() {
  local user_idea="$1"
  local meta_prompt
  meta_prompt=$(
    cat <<METAPROMPT
You are a project specification generator. Based on the user's idea below, generate a complete project specification in markdown format.

User's Idea:
${user_idea}

Generate a specification with:
1. A clear project title
2. A detailed goal description
3. Specific, measurable acceptance criteria (use checkboxes)
4. Technical context and constraints
5. Any assumptions or prerequisites

Output ONLY the markdown specification, no explanations.
METAPROMPT
  )

  local generated
  if generated=$(timeout 60 opencode run "${OPENCODE_OPTS[@]}" <<<"$meta_prompt" 2>/dev/null); then
    echo "$generated"
  else
    # Fallback if AI fails
    cat <<FALLBACK
# Project

## Goal
${user_idea}

## Acceptance Criteria
- [ ] Core functionality implemented
- [ ] Tests passing

## Context
[Add any additional context]
FALLBACK
  fi
}

# Show AI prompt review menu
_ai_show_review_menu() {
  echo "" >&2
  echo "========================================" >&2
  echo " Review Generated Prompt" >&2
  echo "========================================" >&2
  echo "" >&2
  echo "  a) Accept - Use this prompt as-is" >&2
  echo "  e) Edit   - Open in editor to customize" >&2
  echo "  r) Retry  - Describe your idea again" >&2
  echo "  c) Cancel - Abort and use standard template" >&2
  echo "" >&2

  local choice
  while true; do
    printf "Enter choice [a/e/r/c]: " >&2
    read -r choice </dev/tty
    case "$choice" in
    a | A)
      echo "accept"
      return
      ;;
    e | E)
      echo "edit"
      return
      ;;
    r | R)
      echo "retry"
      return
      ;;
    c | C)
      echo "cancel"
      return
      ;;
    *) echo "Invalid choice. Please enter a, e, r, or c." >&2 ;;
    esac
  done
}

# Generate an AI-enhanced prompt from user's idea
# Returns: final prompt content (accepted, edited, or fallback to standard)
generate_ai_enhanced_prompt() {
  local cache_dir idea_file edit_file editor template_content user_idea generated choice
  cache_dir=$(get_ralph_cache_dir)
  idea_file="${TEMP_FILE_PREFIX}_ai_idea_temp.md"
  edit_file="${TEMP_FILE_PREFIX}_ai_edit_temp.md"
  editor=$(get_editor)

  # Track the previous idea for re-prompting
  local previous_idea=""

  echo "" >&2
  echo "========================================" >&2
  echo " AI Enhanced Prompt Generator" >&2
  echo "========================================" >&2

  while true; do
    echo "" >&2
    echo "Opening editor for you to describe your idea..." >&2

    # Write idea template (with previous idea if re-prompting)
    get_ai_idea_template "$previous_idea" >"$idea_file"
    template_content=$(get_ai_idea_template "")

    # Open editor for user to write their idea
    "$editor" "$idea_file" </dev/tty >/dev/tty

    # Read the user's idea
    user_idea=$(cat "$idea_file")
    rm -f "$idea_file"

    # Check if content was modified (only for first attempt)
    if [ -z "$previous_idea" ] && [ "$user_idea" = "$template_content" ]; then
      echo "Error: Idea was not modified. Using standard template." >&2
      get_standard_template
      return 0
    fi

    # Check if empty
    if [ -z "$user_idea" ] || ! echo "$user_idea" | grep -q '[^[:space:]]'; then
      echo "Error: No idea provided. Using standard template." >&2
      get_standard_template
      return 0
    fi

    # Save for potential re-prompt
    previous_idea="$user_idea"

    echo "" >&2
    echo "Generating enhanced prompt from your idea..." >&2
    echo "" >&2

    # Generate the AI-enhanced prompt
    generated=$(_ai_generate_spec "$user_idea")

    # Display the generated prompt
    echo "========================================" >&2
    echo " Generated Prompt Preview" >&2
    echo "========================================" >&2
    echo "" >&2
    echo "$generated" >&2
    echo "" >&2
    echo "========================================" >&2

    # Show review menu
    choice=$(_ai_show_review_menu)

    case "$choice" in
    accept)
      # User accepts as-is, signal to skip editor via marker file
      touch "${cache_dir}/.ai_skip_editor_$$"
      echo "$generated"
      return 0
      ;;
    edit)
      # Open editor for final customization
      echo "$generated" >"$edit_file"
      "$editor" "$edit_file" </dev/tty >/dev/tty
      local edited
      edited=$(cat "$edit_file")
      rm -f "$edit_file"
      # Signal to skip editor via marker file
      touch "${cache_dir}/.ai_skip_editor_$$"
      echo "$edited"
      return 0
      ;;
    retry)
      # Loop back with previous idea prefilled
      echo "" >&2
      echo "Let's try again..." >&2
      continue
      ;;
    cancel)
      echo "" >&2
      echo "Cancelled. Using standard template." >&2
      get_standard_template
      return 0
      ;;
    esac
  done
}

# Prompt Functions
# =============================================================================

# Launch user's editor to create a prompt interactively
launch_editor_for_prompt() {
  local cache_dir ts dir_name prompt_file editor original_mtime original_content new_mtime new_content
  local template_type template_content session_marker skip_editor_marker
  cache_dir=$(get_ralph_cache_dir)
  ts=$(date +%Y-%m-%d-%H%M%S)
  dir_name=$(get_sanitized_dirname)
  prompt_file="${cache_dir}/${ts}_${dir_name}.md"
  session_marker=$(get_session_prompt_marker)
  skip_editor_marker="${cache_dir}/.ai_skip_editor_$$"

  # Show template selection menu
  template_type=$(show_template_menu)

  # Get content based on selection
  case "$template_type" in
  standard)
    template_content=$(get_standard_template)
    ;;
  quickfix)
    template_content=$(get_quickfix_template)
    ;;
  ai)
    template_content=$(generate_ai_enhanced_prompt)
    ;;
  example)
    local example_path
    example_path=$(show_example_menu)
    if [ -n "$example_path" ]; then
      template_content=$(load_example_prompt "$example_path")
    else
      template_content=$(get_standard_template)
    fi
    ;;
  blank)
    template_content=$(get_blank_template)
    ;;
  *)
    template_content=$(get_standard_template)
    ;;
  esac

  # Write content to prompt file
  echo "$template_content" >"$prompt_file"

  # Check if AI flow already handled editing (skip editor marker exists)
  if [ -f "$skip_editor_marker" ]; then
    rm -f "$skip_editor_marker"
    # Store the prompt file path in session marker for reuse across iterations
    echo "$prompt_file" >"$session_marker"
    echo "Prompt saved to: $prompt_file" >&2
    cat "$prompt_file"
    return 0
  fi

  # Capture original state for modification check
  original_content=$(cat "$prompt_file")
  # stat -f %m for macOS, stat -c %Y for Linux
  original_mtime=$(stat -f %m "$prompt_file" 2>/dev/null || stat -c %Y "$prompt_file" 2>/dev/null)

  editor=$(get_editor)
  echo "" >&2
  echo "Opening editor to customize your prompt..." >&2
  echo "Prompt will be saved to: $prompt_file" >&2

  "$editor" "$prompt_file" </dev/tty >/dev/tty

  # Check if file was modified
  new_mtime=$(stat -f %m "$prompt_file" 2>/dev/null || stat -c %Y "$prompt_file" 2>/dev/null)
  new_content=$(cat "$prompt_file")

  # Fail if file wasn't saved (mtime unchanged)
  if [ "$original_mtime" = "$new_mtime" ]; then
    echo "Error: Prompt file was not saved. Aborting." >&2
    rm -f "$prompt_file"
    exit 1
  fi

  # Fail if content is unchanged from template
  if [ "$new_content" = "$original_content" ]; then
    echo "Error: Prompt file was not modified from template. Aborting." >&2
    rm -f "$prompt_file"
    exit 1
  fi

  # Fail if file is empty or only whitespace
  if [ ! -s "$prompt_file" ] || ! grep -q '[^[:space:]]' "$prompt_file"; then
    echo "Error: Prompt file is empty. Aborting." >&2
    rm -f "$prompt_file"
    exit 1
  fi

  # Store the prompt file path in session marker for reuse across iterations
  echo "$prompt_file" >"$session_marker"
  echo "Prompt saved to: $prompt_file" >&2

  cat "$prompt_file"

  # Mark prompt as accepted and save session
  # This ensures sessions are only saved after user has accepted the prompt
  if [ -n "$SESSION_ID" ]; then
    echo "" >&2
    echo "üíæ Saving session..." >&2
    PROMPT_ACCEPTED=true
    # Get user's original prompt file path
    user_prompt_file=$(cat "$session_marker")
    # Save session with separated files
    save_session "$SESSION_ID" 0 "$MAX_ROUNDS" "$user_prompt_file"
    echo "‚úÖ Session saved successfully" >&2
  fi

  # Show confirmation prompt unless RALPH_PROMPT is set (non-interactive mode)
  if [ -z "${RALPH_PROMPT:-}" ]; then
    echo "" >&2
    echo "========================================" >&2
    echo "Prompt accepted. Ready to execute?" >&2
    echo "========================================" >&2
    echo "" >&2
    cat "$prompt_file"
    echo "" >&2
    echo -n "   Proceed with execution? (y/n) " >&2
    read -n 1 -r reply </dev/tty >/dev/tty
    echo "" >&2
    if [[ ! $reply =~ ^[Yy]$ ]]; then
      echo "Aborting. Run './ralph' again to restart." >&2
      exit 0
    fi
  fi

  return 0
}

# Determine prompt source and return content
get_prompt() {
  local session_marker session_prompt_file response

  # Priority 1: RALPH_PROMPT environment variable
  if [ -n "${RALPH_PROMPT:-}" ]; then
    echo "Using RALPH_PROMPT" >&2
    echo "$RALPH_PROMPT"
    return
  fi

  # Priority 2: RALPH_PROMPT_FILE environment variable
  if [ -n "${RALPH_PROMPT_FILE:-}" ]; then
    if [ ! -f "$RALPH_PROMPT_FILE" ]; then
      echo "Error: RALPH_PROMPT_FILE points to a missing file: '$RALPH_PROMPT_FILE'" >&2
      exit 1
    fi
    echo "Using RALPH_PROMPT_FILE" >&2
    cat "$RALPH_PROMPT_FILE"
    return
  fi

  # Priority 3: Session prompt file (created via interactive editor this session)
  session_marker=$(get_session_prompt_marker)
  if [ -f "$session_marker" ]; then
    session_prompt_file=$(cat "$session_marker")
    if [ -f "$session_prompt_file" ]; then
      echo "Using SESSION PROMPT MARKER" >&2
      cat "$session_prompt_file"
      return
    fi
  fi

  # Priority 4: Default prompt.md file (or temp file from resume)
  if [ -f "$PROMPT_FILE" ]; then
    # When resuming, offer to review/modify the prompt
    if [ -n "$RALPH_RESUME" ]; then
      if [ -t 0 ]; then
        echo "üìù Found prompt from previous session:" >&2
        echo "" >&2
        echo "----------------------------------------" >&2
        head -20 "$PROMPT_FILE" >&2
        if [ $(wc -l <"$PROMPT_FILE") -gt 20 ]; then
          echo "   ... (more lines)" >&2
        fi
        echo "----------------------------------------" >&2
        echo "" >&2
        echo "Would you like to review and modify it before continuing?" >&2
        echo "(y/n, default: y)" >&2
        echo -n "   > " >&2
        read -r response </dev/tty >/dev/tty
        echo "" >&2
        if [[ "$response" =~ ^[Yy] ]] || [ -z "$response" ]; then
          echo "Opening editor with your prompt..." >&2
          echo "Press :wq to save and exit." >&2
          echo "" >&2
          launch_editor_for_prompt_with_file "$PROMPT_FILE"
          echo "" >&2
        fi
        echo "üìù Using modified prompt." >&2
        cat "$PROMPT_FILE"
        return
      else
        echo "Using PROMPT_FILE from resume" >&2
        cat "$PROMPT_FILE"
        return
      fi
    fi
    echo "Using PROMPT_FILE" >&2
    cat "$PROMPT_FILE"
    return
  fi

  # Priority 5: No prompt found - guide through creation
  echo "" >&2
  echo "üìù No prompt found for this session." >&2
  echo "" >&2

  # Check if we have TTY for interactive input
  if [ -t 0 ]; then
    echo "Would you like to create a new prompt?" >&2
    echo "(y/n, default: y)" >&2
    echo -n "   > " >&2
    read -r response </dev/tty >/dev/tty
    echo "" >&2
    if [[ "$response" =~ ^[Nn] ]]; then
      echo "Aborting: No prompt to work with." >&2
      exit 1
    fi
  else
    # Non-interactive: try to find prompt.md in the original directory
    if [ -n "$RESUME_ORIGINAL_DIR" ] && [ -f "${RESUME_ORIGINAL_DIR}/prompt.md" ]; then
      cp "${RESUME_ORIGINAL_DIR}/prompt.md" "$PROMPT_FILE"
      echo "Using prompt.md from session directory" >&2
      cat "$PROMPT_FILE"
      return
    fi
    echo "Error: No prompt found and running non-interactive. Aborting." >&2
    exit 1
  fi

  # Launch interactive editor with template selection
  launch_editor_for_prompt
}

# Launch editor to modify an existing prompt file
launch_editor_for_prompt_with_file() {
  local prompt_file="$1"
  local session_marker editor original_mtime original_content new_mtime new_content

  if [ ! -f "$prompt_file" ]; then
    echo "Error: Prompt file not found: $prompt_file" >&2
    return 1
  fi

  session_marker=$(get_session_prompt_marker)
  editor=$(get_editor)

  # Capture original state for modification check
  original_content=$(cat "$prompt_file")
  # stat -f %m for macOS, stat -c %Y for Linux
  original_mtime=$(stat -f %m "$prompt_file" 2>/dev/null || stat -c %Y "$prompt_file" 2>/dev/null)

  echo "" >&2
  echo "Opening editor to modify your prompt..." >&2
  echo "Press :wq to save and exit." >&2

  # Only try TTY if we have one
  if [ -t 0 ]; then
    "$editor" "$prompt_file" </dev/tty >/dev/tty
  else
    "$editor" "$prompt_file"
  fi

  # Check if file was modified
  new_mtime=$(stat -f %m "$prompt_file" 2>/dev/null || stat -c %Y "$prompt_file" 2>/dev/null)
  new_content=$(cat "$prompt_file")

  # If not modified, keep original content
  if [ "$original_mtime" = "$new_mtime" ]; then
    echo "Note: Prompt was not saved. Using original content." >&2
    return 0
  fi

  # Fail if file is empty or only whitespace
  if [ ! -s "$prompt_file" ] || ! grep -q '[^[:space:]]' "$prompt_file"; then
    echo "Error: Prompt file is empty. Keeping original content." >&2
    echo "$original_content" >"$prompt_file"
    return 1
  fi

  # Store the prompt file path in session marker for reuse
  echo "$prompt_file" >"$session_marker"
  echo "Prompt updated." >&2
}

# Get prompt without interactive fallback (for validation)
get_prompt_nointeractive() {
  local session_marker session_prompt_file

  # Priority 1: RALPH_PROMPT environment variable
  if [ -n "${RALPH_PROMPT:-}" ]; then
    echo "$RALPH_PROMPT"
    return 0
  fi

  # Priority 2: RALPH_PROMPT_FILE environment variable
  if [ -n "${RALPH_PROMPT_FILE:-}" ] && [ -f "$RALPH_PROMPT_FILE" ]; then
    cat "$RALPH_PROMPT_FILE"
    return 0
  fi

  # Priority 3: Session prompt file (created via interactive editor this session)
  session_marker=$(get_session_prompt_marker)
  if [ -f "$session_marker" ]; then
    session_prompt_file=$(cat "$session_marker")
    if [ -f "$session_prompt_file" ]; then
      cat "$session_prompt_file"
      return 0
    fi
  fi

  # Priority 4: Default prompt.md file
  if [ -f "$PROMPT_FILE" ]; then
    cat "$PROMPT_FILE"
    return 0
  fi

  # Return default for validation context (no interactive fallback)
  echo "[No original prompt available - validate based on current state]"
  return 0
}

# Check if process was terminated by a signal (e.g., Ctrl+C)
# Signal exit codes are 128 + signal number
# SIGINT (Ctrl+C) = 130, SIGTERM = 143
check_signal_termination() {
  local code="$1"
  if [ "$code" -ge 128 ]; then
    local signal_num=$((code - 128))
    case "$signal_num" in
    2)
      echo "SIGINT (Ctrl+C)"
      return 0
      ;;
    15)
      echo "SIGTERM"
      return 0
      ;;
    *)
      echo "Signal $signal_num"
      return 0
      ;;
    esac
  fi
  return 0
}

# Sanitize content to prevent heredoc injection
sanitize_for_heredoc() {
  local content="$1"
  echo "${content//EOF/RALPH_SAFE_EOF_MARKER}"
}

# Get validation status from result
get_validation_status() {
  local result="$1"
  echo "$result" | grep -o '<validation_status>[^<]*</validation_status>' | sed 's/<[^>]*>//g' | tr -d ' '
}

# Progress refactoring to prevent file from growing too large - REMOVED
# Progress file management is now delegated entirely to the AI agent.
# The agent is responsible for updating and maintaining progress.md.

# Ensure progress file exists
if [ ! -f "$PROGRESS_FILE" ]; then
  touch "$PROGRESS_FILE"
fi

# Main loop - skip if RALPH_SOURCED_FOR_TEST is set
if [ "${RALPH_SOURCED_FOR_TEST:-0}" = "1" ]; then
  : # Skip main loop when sourcing for testing
else
  # Generate session ID for tracking (skip if already set by resume)
  if [ -z "$SESSION_ID" ]; then
    SESSION_ID=$(generate_session_id)
  fi

  # Check for existing incomplete sessions in this directory (skip when resuming)
  if [ -z "$RALPH_RESUME" ]; then
    check_incomplete_sessions || true
  fi

  echo "üìÅ Session ID: $SESSION_ID"
  echo ""

  # For non-interactive mode (RALPH_PROMPT set), save session immediately
  # For interactive mode, session will be saved after prompt acceptance
  if [ -n "${RALPH_PROMPT:-}" ]; then
    echo "üíæ Non-interactive mode detected. Saving session..." >&2

    # Save RALPH_PROMPT to a temp file for session storage
    temp_user_prompt="${TEMP_FILE_PREFIX}_user_prompt.md"
    echo "$RALPH_PROMPT" >"$temp_user_prompt"

    save_session "$SESSION_ID" 0 "$MAX_ROUNDS" "$temp_user_prompt"
    PROMPT_ACCEPTED=true
    rm -f "$temp_user_prompt" # Clean up temp file

    echo "‚úÖ Session saved successfully" >&2
    echo "" >&2
  fi

  # Session directory will be created when prompt is accepted
  # This ensures sessions are only saved after user confirmation

  PROMPT_CONTENT=""
  for ((i = 1; i <= MAX_ROUNDS; i++)); do
    echo "========================================"
    echo "üîÑ RalphLoop Iteration $i of $MAX_ROUNDS"
    echo "========================================"

    if [ -z "$PROMPT_CONTENT" ]; then
      # Read current progress and prompt
      PROGRESS_CONTENT=$(cat "$PROGRESS_FILE")
      PROMPT_CONTENT=$(get_prompt)

      # Sanitize content to prevent heredoc injection
      SANITIZED_PROGRESS=$(sanitize_for_heredoc "$PROGRESS_CONTENT")
      SANITIZED_PROMPT=$(sanitize_for_heredoc "$PROMPT_CONTENT")
    fi

    # Check for pending validation issues from previous incomplete validation
    PENDING_ISSUES=""
    if [ -f "$VALIDATION_ISSUES_FILE" ]; then
      PENDING_ISSUES=$(cat "$VALIDATION_ISSUES_FILE")
    fi

    # Build context section with pending issues if any
    CONTEXT_SECTION=""
    if [ -n "$PENDING_ISSUES" ]; then
      CONTEXT_SECTION=$(
        cat <<CONTEXT_SECTION
## üö® PENDING VALIDATION ISSUES FROM PREVIOUS ITERATION
The previous completion attempt failed validation. You MUST fix these issues:

\`\`\`markdown
${PENDING_ISSUES}
\`\`\`

## Your Priority

Focus ONLY on resolving these validation issues. Do NOT work on new features.
After fixing, mark complete with <promise>COMPLETE</promise> for re-validation.
CONTEXT_SECTION
      )
    fi

    # Show progress indicator while command runs
    echo "üöÄ Starting agent execution..."
    echo "   (This may take a moment. Progress will be shown below.)"
    echo ""

    # Use tee to both save to file AND display output in real-time
    # This provides feedback while ensuring output is captured for later analysis
    # Use set +e to allow opencode to fail without exiting the script
    # Signal handling via trap (see cleanup function above) provides graceful termination
    set +e
    tmp_prompt_file="${TEMP_FILE_PREFIX}_prompt.txt"
    cat >"$tmp_prompt_file" <<EOF
# Goals and Resources

## Project plan

${SANITIZED_PROMPT}

## Current Progress

${SANITIZED_PROGRESS}
${CONTEXT_SECTION}
${RALPH_PROMPTS}
EOF

    set +e # Don't exit on non-zero exit from wait
    # Run opencode in background with trap-based signal handling
    # This replaces the timeout command for better control over signals
    OPENCODE_PID=""
    opencode run "${OPENCODE_OPTS[@]}" <"$tmp_prompt_file" 2>&1 | tee "$OUTPUT_FILE" &
    OPENCODE_PID=$!

    # Wait for opencode process with proper signal handling
    # Using a loop to detect edge cases where wait returns early
    # Fixed: Ensure we always wait for the process and capture exit code correctly
    wait "$OPENCODE_PID" 2>/dev/null
    EXIT_CODE=$?
    set -e # Re-enable exit on error

    if [ $EXIT_CODE -ne 0 ]; then
      echo "‚ö†Ô∏è  Main process exited with code: $EXIT_CODE" >&2
    fi

    # Read output from file (trap may delete the file if interrupted)
    result=$(cat "$OUTPUT_FILE" 2>/dev/null | tr -d '\0' || echo "")

    signal_name=$(check_signal_termination "$EXIT_CODE")
    if [ -n "$signal_name" ]; then
      echo ""
      echo "üõë Process terminated by $signal_name"
      echo "   Stopping RalphLoop iterations."
      echo "========================================"
      rm -f "$OUTPUT_FILE"
      fail_session "$SESSION_ID"
      exit 130
    fi

    # Check for non-zero exit code from opencode
    if [ "$EXIT_CODE" -ne 0 ]; then
      echo "‚ùå ERROR: opencode command failed with exit code $EXIT_CODE" >>"$OUTPUT_FILE"
    fi

    # Check if result is empty or indicates an error
    if [ -z "$result" ]; then
      echo "‚ö†Ô∏è WARNING: Empty output from opencode agent - may indicate memory or execution issue"
      rm -f "$OUTPUT_FILE"
      echo "Continuing to next iteration..."
      echo ""
      continue
    fi

    # Output has already been streamed via tee, just show separator
    echo ""
    echo "--- Output complete ---"
    rm -f "$OUTPUT_FILE"

    # Check for completion
    if echo "$result" | grep -q "<promise>COMPLETE</promise>"; then
      echo ""
      echo "üõ°Ô∏è Goal marked complete. Running independent validation..."
      echo "========================================"

      # Run validation prompt to verify completion criteria are truly met - stream output for real-time feedback
      # Using trap-based signal handling instead of timeout command for full control
      VALIDATION_OUTPUT_FILE="${TEMP_FILE_PREFIX}_validation.txt"

      echo "üõ°Ô∏è Running independent validation..."
      echo ""

      VALIDATION_PROMPT=$(
        cat <<RALPH_VALIDATE_EOF
# Validation Task

The agent previously indicated completion with <promise>COMPLETE</promise>.

You must INDEPENDENTLY VERIFY that all acceptance criteria are actually met.

## Original Project Goal (from prompt.md):
$(get_prompt_nointeractive)

## Your Validation Task:

1. READ the current state
2. CHECK each acceptance criterion is actually satisfied:
    - For each requirement, verify it exists and works
    - Run tests, build commands, and manual checks
3. RUN comprehensive verification:
    - [ ] Code compiles/builds without errors (run: npm run build or equivalent)
    - [ ] Tests pass (run: npm test or equivalent)
    - [ ] No linting errors (run: npm run lint or equivalent)
    - [ ] All acceptance criteria from prompt.md are met
    - [ ] No regressions in existing functionality
4. OUTPUT your findings in this exact XML format:

no issues found: <validation_status>PASS</validation_status>
issues fund: <validation_status>FAIL</validation_status>

<validation_issues>
- [List each failing criterion with specific details]
- Leave empty if PASS
</validation_issues>

<validation_recommendations>
- [Specific actions needed to fix each issue]
- Leave empty if PASS
</validation_recommendations>

IMPORTANT:
- If ALL checks pass, use <validation_status>PASS</validation_status>
- If ANY check fails, use <validation_status>FAIL</validation_status> and list all issues
- Do NOT trust the previous agent's assessment. Verify independently.
RALPH_VALIDATE_EOF
      )

      # Use timeout command for validation with proper signal handling
      set +e # Don't exit on error
      OPENCODE_PID=""
      opencode run "${OPENCODE_OPTS[@]}" "$VALIDATION_PROMPT" 2>&1 | tee "$VALIDATION_OUTPUT_FILE" &
      OPENCODE_PID=$!
      wait "$OPENCODE_PID" 2>/dev/null
      VALIDATION_EXIT_CODE=${PIPESTATUS[0]} # Get exit code from timeout/opencode command
      set -e                                # Re-enable exit on error

      if [ "$VALIDATION_EXIT_CODE" == "0" ]; then
        echo "‚ö†Ô∏è  Validation process exited with code: $VALIDATION_EXIT_CODE" >&2
      fi

      signal_name=$(check_signal_termination "$VALIDATION_EXIT_CODE")
      if [ -n "$signal_name" ]; then
        echo ""
        echo "üõë Validation terminated by $signal_name"
        echo "   Stopping RalphLoop iterations."
        echo "========================================"
        rm -f "$VALIDATION_OUTPUT_FILE"
        fail_session "$SESSION_ID"
        exit 130
      fi

      validation_result=$(cat "$VALIDATION_OUTPUT_FILE" | tr -d '\0')
      rm -f "$VALIDATION_OUTPUT_FILE"

      # Output has already been streamed via tee, just show completion message
      echo ""
      echo "--- Validation complete ---"

      # Extract and check validation status
      VALIDATION_STATUS=$(get_validation_status "$validation_result")

      if [ "$VALIDATION_STATUS" = "PASS" ]; then
        echo ""
        echo "üéâ Validation PASSED! RalphLoop mission complete!"
        echo "========================================"
        # Mark session as complete
        complete_session "$SESSION_ID"
        # Progress file management is delegated to the AI agent
        rm -f "$VALIDATION_ISSUES_FILE"
        exit 0
      else
        echo "‚ö†Ô∏è Validation FAILED. Saving issues for next iteration..."

        echo ""
        echo "üìã Validation Results:"
        echo "-----------------------------------"
        echo "$validation_result"
        echo "-----------------------------------"

        echo "Issues saved to ${VALIDATION_ISSUES_FILE}"
        echo "Agent will prioritize fixing these in next iteration."
        echo ""
      fi
    fi

    # Save session state after each iteration
    save_session "$SESSION_ID" "$i" "$MAX_ROUNDS"

    echo ""
    echo "‚úÖ Iteration $i complete. Continuing..."
    echo ""
  done

  echo "========================================"
  echo "üèÅ Max iterations ($MAX_ROUNDS) reached."
  echo "   RalphLoop will rest for now."
  echo "========================================"
fi
